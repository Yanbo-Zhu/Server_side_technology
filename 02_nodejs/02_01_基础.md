

# 1 Die Javascript-Laufzeitumgebung in node.js

![](images/Pasted%20image%2020250116213521.png)



# 2 Integrierte Module (Auswahl)

| Modulname           | Beschreibung                                                     |
| ------------------- | ---------------------------------------------------------------- |
| `**assert**`        | Integriertes Testframework                                       |
| `**buffer**`        | Modul für den Umgang mit binären Rohdaten                        |
| `**child_process**` | Verwaltung von Kindprozessen                                     |
| `**cluster**`       | Prozessverwaltung für Mehrkernprozessoren                        |
| **`console`**       | console-Funktionalität in JavaScript                             |
| `**crypto**`        | Sichere Verbindung und Verschlüsselung                           |
| `**debugger**`      | Mittel zur Laufzeitanalyse von Applikationen                     |
| `**dgram**`         | Kommunikation über UDP                                           |
| `**dns**`           | Namensauflösung unter Node.js                                    |
| `**domain**`        | Sammlung von Exceptions und Fehlern einer Gruppe von Operationen |
| `**events**`        | Basismodul für Objekte, die Events erzeugen                      |
| `**fs**`            | Dateisystemoperationen                                           |
| `**http**`          | HTTP-Client und -Server                                          |
| `**https**`         | HTTPS-Client und -Server                                         |
| `**module**`        | Modulloader von Node.js                                          |
| `**net**`           | Client- und Serverkomponenten für Netzwerkstreams                |
| `**os**`            | Betriebssystemoperationen auslesen                               |

|Modulname|Beschreibung|
|---|---|
|`**path**`|Umgang mit Pfadinformationen|
|`**punycode**`|Codierung und Decodierung von Punycode-Zeichenketten|
|`**querystring**`|Erstellung und Parsing von URL Query Strings|
|`**readline**`|Einlesen von Informationen über einen Stream wie die Standardeingabe|
|`**repl**`|Interaktive Node.js-Shell|
|`**stream**`|Schreib- und lesbare Datenstreams|
|`**string_decoder**`|Umwandlung von Buffer-Objekten in Zeichenketten|
|`**timers**`|Zeitabhängige Funktionen|
|`**tls**`|Verschlüsselte Kommunikation über Datenstreams|
|`**tty**`|Zwischenschicht zum Ansprechen von Standardein- und -ausgabe|
|`**url**`|Funktionalität zum Umgang mit URLs|
|`**util**`|Hilfsfunktionen|
|`**vm**`|Ausführungsumgebung für JavaScript-Code|
|`**zlib**`|Möglichkeit zum Komprimieren und Dekomprimieren von Daten|

# 3 Möglichkeiten der Kommunikation


![](images/Pasted%20image%2020250118132724.png)


![](images/Pasted%20image%2020250118132822.png)

- Traditionelle Kommunikation über das HTTP-Protokoll

- Kommunikation über eine sichere HTTP-Verbindung
- Umsetzung der sicheren Verbindung über Transport Layer Security (TLS) zwischen TCP und HTTP
- Authentifizierung (des besuchten Servers oder gegenseitig), Vertraulichkeit, Integrität

- Websockets: direkte Kommunikation über das Transportprotokoll (TCP oder UDP)


# 4 Einfache Node.js-Server

## 4.1 Rückgabe von Text


1 addListener

```js
// run `node server01.js in the terminal 
console.log(`Hello Node.js v${process.versions.node}!`);
let Server=require('http').Server;  // 从 http 中拿一个 server 
let server=new Server();
server.addListener('request', function(request, response) {
  response.writeHead(200, {
    'content-typ': 'text/plain; charset=utf-8'
  });
  response.write('Hello ');
  response.end('World\n');
});
server.listen(8080);
console.log('Webserver wird ausgeführt.');
```



运行 noder server01.js 

得到 
![](images/Pasted%20image%2020250118133338.png)


console 中得到 
```
hello nodejs v18.2a
Webserver wird ausgeführt
```

- Registrierung der Callback-Funktion mittels `**addListener**`-Methode auf dem `**server**`-Objekt
- `**addListener**` hat gleiche Funktionsweise wie `**addEventListener**` bei JavaScript im Browser
- `**addListener**` ist eine Alias für `**on**`
- Übergabe einer Callback-Funktion bei Erzeugung des Servers, die bei jeder HTTP-Anfrage durch die Laufzeitumgebung aufgerufen wird
- `**request**`: Zugriff auf Header-Felder und Inhalte der HTTP-Anfrage
- `**response**`: Zugriff auf Header-Felder und Inhalte der HTTP-Antwort
- Zusammenstellen einer HTML-Seite mittels **writeHead** (für Header-Parameter) bzw. **write** auf dem **response**-Objekt


---

2 createServer 

- `**createServer**` als alternative (und bevorzugte) Methode zur Erzeugung des Webservers
- Übergabe einer Callback-Funktion, die bei einem eintreffenden Request aufgerufen wird
- Ersetzt `**addEventListener**`

```js
// run `node server02.js in the terminal 
console.log(`Hello Node.js v${process.versions.node}!`);
let http=require('http');
http.createServer(function(request, response) {
  response.writeHead(200, {
    'content-typ': 'text/plain; charset=utf-8'
  });
  response.write('Hello ');
  response.end('World\n');
}).listen(8080);
console.log('Webserver wird ausgeführt.');
```


得到 
![](images/Pasted%20image%2020250118133507.png)


## 4.2 Auslesen von QUERY-Parametern

```js
// run `node server04.js` in the terminal
console.log(`Hello Node.js v${process.versions.node}!`);
let http=require('http');
let url=require('url');
http.createServer(function(request, response) {
  response.writeHead(200, {
    'content-typ': 'text/html; charset=utf-8'
  });
  let urlString=url.parse(request.url,true);  // 用于 读取 ulr string 中的 内容 
  let body='<!DOCTYPE html>'+
  '<html>'+
  '<head>'+
  '<meta charset="utf-8">'+'<title>Node.js-Demo</title>'+
  '</head>'+
  '<body>'+
  '<h1 style="color: green">Hello '+urlString.query.name+'</h1>'+  // urlString.query.name 用来读取 query 中的 name 
  '</body>'+
  '</html>';
  response.end(body);
}).listen(8080);
console.log('Webserver wird ausgeführt.');
```

得到 

![](images/Pasted%20image%2020250118150312.png)

如果在 url 中 不写 ?name=thomas , 则会显示 Hello undefined 


## 4.3 Auslesen des Request Body

一个 request 一般来说 会分批到来 ,  读取每个 packet 中的 data, 
以及 在 包全都到来后, 去做 什么动作 

```js
// run `node server05.js` in the terminal
console.log(`Hello Node.js v${process.versions.node}!`);
let http=require('http');

http.createServer(function(request, response) {
  let body='';
  request.on('data', function(data) {
    body+=data.toString();
  });
  request.on('end', function() {
    console.log(body);
    response.writeHead(200, {'content-type': 'text/plain'});
    response.end(body);
  });
}).listen(8080);

console.log('Webserver wird ausgeführt.');
```


Testen mit:
```sh
curl -d "user=foobar&pass=12345&id=blablabla&ding=submit" http://localhost:8080
```


- Problem: Body einer HTTP-Anfrage kann in mehreren Teilen übertragen werden, d.h. in mehreren TCP-Segmenten
- Betroffen sind `**POST**`- und `PUT`-Nachrichten
- Verschiedene Events informieren Node.js-Server über den Zustand einer HTTP-Anfrage
    - `**data**`: wird ausgelöst, sobald neue Daten geliefert werden
    - `**end**`: wird ausgelöst, sobald die Übermittlung sämtlicher Teile einer Anfrage abgeschlossen ist
    - `**close**`: signalisiert, dass die TCP-Verbindung beendet wurde
- Bearbeitung der Ereignisse durch Callback-Funktionen
- Beispiel: die in einem TCP-Segment übermittelten Daten werden in der Callback-Funktion übergeben und lassen sich in einem Buffer zwischenspeichern
- Beachte: `**end**` und `**close**` werden pro Anfrage nur einmal ausgelöst
- Beachte: tritt `**close**` vor `**end**` auf, ist Übertragung unvollständig
- Beachte: `**on**`-Methode alternativ für `**addListener**`


# 5 Auslieferung statischer Dateien

nodeserver   去读取一个 datei, 把他发给前端 

```js
const http = require('http');
const fs = require('fs');
const url = require('url');
const path = require('path');

const hostname = process.env.HOST || 'localhost';
const port = process.env.PORT || 80;

http.createServer( function (request, response) {

   //Angefragter Pfadname in der URL separieren
   let pathname = url.parse(request.url).pathname;

   //Wen kein Pfadname angegeben wurde, indedx.html per default laden
   if (pathname=='/') pathname='/index.html';

   //Pfadname auf dem Server entspricht dem absoluten Pfad des Webserver (=Current Working Directory, cwd)+Pfadname der URL
   let fullpath = path.join(process.cwd(),pathname);

   console.log("Request for " + pathname + " received.");
   fs.readFile(fullpath, function (err, data) {
      if (err) {
         console.log(err);
         response.writeHead(404, {'Content-Type': 'text/html'});
      } else {

         //Je nach Art des angefragten Inhalts muss im HTTP-Response-Header der Content-Type dementsprechend gesetzt werd
         let fileNameExtension=path.extname(pathname);

         if (fileNameExtension===".html") {
            response.writeHead(200, {'Content-Type': 'text/html'});
         }
         else if (fileNameExtension===".css") {
            response.writeHead(200, {'Content-Type': 'text/css'});
         }
         else if (fileNameExtension===".js") {
            response.writeHead(200, {'Content-Type': 'text/javascript'});
         }
         else if (fileNameExtension===".jpg") {
            response.writeHead(200, {'Content-Type': 'image/jpeg'});
         }
         else if (fileNameExtension===".png") {
            response.writeHead(200, {'Content-Type': 'image/png'});
         }
         else response.writeHead(200, {'Content-Type': 'text/plain'});
         response.write(data);
      }
     response.end();
   });
}).listen(port, hostname, ()=>console.log('Webserver wird ausgeführt unter http://'+hostname+':'+port+'.'));
console.log('Webserver wird gestartet.');
```

- Bisher: dynamische Erzeugung einer HTTP-Antwort
- Hier: Übertragung einer statischen Datei (text oder HTML) aus dem Dateiverzeichnis des Servers
- Benötigte Module: `**http**`, **`url`**, `**fs**`
- `**url**`: Operationen auf URLs, z.B. Extraktion des Pfadnamens
- `**fs**`: Operationen auf dem lokalen Dateisystem, zum Beispiel Lesen oder Schreiben von Dateien
- Beachte: Lesen einer Datei erfolgt asynchron, d.h. Verarbeitung der gelesenen Daten durch Callback-Funktion

# 6 Node.js als Client

就是 server-seite and Client-server 放到一起使用 

![](images/Pasted%20image%2020250118151344.png)


下面两个 都是 发送一个 request , 并且 在同一个 request 函数汇总已经定义好了 response 的 function 

Standardmethode
```js
// run `node client01.js in the terminal 
console.log(`Hello Node.js v${process.versions.node}!`);
let https=require('https');
https.request('https://dummyjson.com/products/1', function(response) {
  response.on('data', function(data) {
    console.log(data.toString());
  });
}).end();
```


Konfiguration der Request-Parameter
```js
// run `node client02.js in the terminal 
console.log(`Hello Node.js v${process.versions.node}!`);
let https=require('https');
https.request({
  host:'dummyjson.com',
  port: 443,
  method: 'GET',
  path:'/products',
  headers: {
    'accept': 'text/json',
    'userAgent': 'node.js'
  },
  agent: false}, function(response) {
    response.on('data', function(data) {
      console.log(data.toString());
  });
}).end();
```



Get-Methode
```js
// run `node client03.js in the terminal 
console.log(`Hello Node.js v${process.versions.node}!`);
let https=require('https');
https.get('https://dummyjson.com/products', function(response) {
  response.on('data', function(data) {
    console.log(data.toString());
  });
}).end();
```



Senden von Daten im Body der Anfrage
就是 request 的 body 中的内容 通过 request.write 
```js
// run `node client04.js in the terminal 
console.log(`Hello Node.js v${process.versions.node}!`);
let https=require('https');
let request=https.request({
  host:'dummyjson.com',
  port: 443,
  method: 'POST',
  path:'/products/add',
  headers: {},
  agent: false}, function(response) {}
);

request.write('{"title":"iPhone 9","description":"An apple mobile which is nothing like apple","price":549,"discountPercentage":12.96,"rating":4.69,"stock":94,"brand":"Apple","category":"smartphones","thumbnail":"https://i.dummyjson.com/data/products/1/thumbnail.jpg","images":["https://i.dummyjson.com/data/products/1/1.jpg","https://i.dummyjson.com/data/products/1/2.jpg","https://i.dummyjson.com/data/products/1/3.jpg","https://i.dummyjson.com/data/products/1/4.jpg","https://i.dummyjson.com/data/products/1/thumbnail.jpg"]}');

request.end();
```

